fork
========================================

简介
----------------------------------------
fork 系统调用将创建一个与父进程几乎一样的新进程，复制了父亲进程的资源，包括内存的内容task_struct内容

在Linux的早期系统中，当发出fork()系统调用时，内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程。这种完整复制需要如下操作：

- 为子进程的页表分配页帧
- 为子进程的页分配页帧
- 初始化子进程的页表
- 把父进程的页复制到子进程相应的页中

现代的Linux内核采用一种更为有效的方法，称之为写时复制（Copy On Write，COW）。父进程和子进程共享页帧而不是复制页帧。然而，只要页帧被共享，它们就不能被修改，即页帧被保护。无论父进程还是子进程何时试图写一个共享的页帧，就产生一个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。原来的页帧仍然是写保护的：当其他进程试图写入时，内核检查写进程是否是这个页帧的唯一属主，如果是，就把这个页帧标记为对这个进程是可写的。

fork失败时返回值为负数，成功时子进程返回0，父进程返回子进程的pid。

缺点
----------------------------------------
不是线程安全的，fork 创建的子进程只有一个线程（调用线程的副本），当一个线程在 fork 时，如果另一个线程此时进行内存分配并持有堆锁，任何在子进程中分配内存的尝试（从而获得相同的锁）都将立即发生死锁。

fork存在性能问题。
